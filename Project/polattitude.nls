; File with functionality regarding the datastructure, handling, 
; updating and monitoring of the agent's political attitude 
; plane.

; FILE HISTORY:

; 2022-04-14 political attitude position and conviction value 
;            calculation. New conviction value can be later sum 
;            if it pass the neighbour check procudure which uses 
;            Manhattan distancing.
;            Authors: Pratchaya Khansomboon (PK), Eric Lundin 
;           (EL), Marcus Linné (ML), Linnéa Mörk (LM)
; 2022-04-15 Fix center of mass calculation, PK
;
;---------------------------------------------------


; Generate the attitude plane heatmap and set it in the beliefs hashmap.
to setup-heatmap
  let rows attitude_rows
  let cols attitude_cols

  let polLeft 12.6
  let polSoc 39.5
  let polMid 9.3
  let polCons 22.1
  let polRight 15.7
  
  let tier1 polLeft
  let tier2 polSoc + tier1
  let tier3 polMid + tier2
  let tier4 polCons + tier3
  let tier5 polRight + tier4

  ask voters [
    let max_heat 10

    let heatmap array:from-list n-values (cols * rows) [0]
    let polVal  random(100)
    let polIndex 0
    
    if polVal < tier1                    [set polIndex 0]
    if tier1 < polVal and polVal < tier2 [set polIndex 1]
    if tier2 < polVal and polVal < tier3 [set polIndex 2]
    if tier3 < polVal and polVal < tier4 [set polIndex 3]
    if tier4 < polVal and polVal < tier5 [set polIndex 4]

    array:set heatmap (1 * cols + polIndex) 1
    add-belief create-belief "attitide-plane" heatmap
    let com center-of-mass heatmap
    set current_pol_attitude item 0 com
  ]
end

; Get the attitude plane current coordinate and the calculated
; conviction based on the attitude plane's heatmap.
;
; return [x y z] where (x, y) is the position and the z is the conviction value.
to-report center-of-mass [heatmap]
  let rows attitude_rows
  let cols attitude_cols

  let sum_mass 0.0
  let sum_particles list 0.0 0.0
  foreach (n-values rows [i -> i]) [
    y -> foreach (n-values cols [j -> j]) [
      x ->
      let index y * rows + x
      let m array:item heatmap index

      let mx m * x
      let my m * y

      let sx item 0 sum_particles
      let sy item 1 sum_particles
      set sum_particles list (mx + sx) (my + sy)
      set sum_mass (sum_mass + m)
    ]
  ]
;  if sum_mass = 0 [set sum_mass 1]
  let x floor (item 0 sum_particles / sum_mass)
  let y floor (item 1 sum_particles / sum_mass)
  let z array:item heatmap (y * rows + x)
  report (list x y z)
end

; Sum the heat (x, y, z) conviction on our heatmap.
; This applies to the current agent.
to sum-heatmap [heat]
  let row attitude_rows
  let heatmap beliefs-of-type "attitude-plane"
  let hx item 0 heat  ; x
  let hy item 1 heat  ; y
  let hz item 2 heat  ; z

  let index hy * row + hx
  let current_z array:item heatmap index
  array:set heatmap index (current_z + hz)
end

; Check if the incoming attitude message is within a range
; of our current position in the attitude plane
;
; true:  message is valid for attitude-plane summation
; false: message not satisfy the attitude-plane summation
to-report neighbour-check [message heatmap]
  let attitude_plane center-of-mass heatmap
  let apx item 0 attitude_plane
  let apy item 1 attitude_plane

  let mx item 0 message
  let my item 1 message

;  ; Euclidean distance
;  let dist_euclidean (apx - mx) * (apx - mx) + (apy - my) * (apy - my)
;  report dist_euclidean <= 1

  ; Manhattan distance
  let dist_x abs(apx - mx)
  let dist_y abs(apy - my)

  report dist_x <= 1 xor dist_y <= 1
end

; This controls our reactive layer.
to react-heatmap
  let conviction_queue beliefs-of-type "incoming-conviction"
end

to-report heatmap-eval
  let conviction_queue beliefs-of-type "incoming-conviction"
  report true
end


