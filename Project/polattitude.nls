; File with functionality regarding the datastructure, handling, 
; updating and monitoring of the agent's political attitude 
; plane.

; FILE HISTORY:

; 2022-04-14 political attitude position and conviction value 
;            calculation. New conviction value can be later sum 
;            if it pass the neighbour check procudure which uses 
;            Manhattan distancing.
;            Authors: Pratchaya Khansomboon (PK), Eric Lundin 
;            (EL), Marcus Linné (ML), Linnéa Mörk (LM)
; 2022-04-15 Fix center of mass calculation, PK
; 2022-04-21 Political attitude generation for based on the
;            project description. This value is set in setup-heatmap
;            for every agent.
;            Author: EL, PK
; 2022-04-22 Fixes matrix indexing for setup-heatmap and center of
;            mass calculation. This causes problem when we were trying to chart 
;            the political attitude percentages.
;            Author: PK
; 2022-04-?? setup-heatmap added by ???
; 2022-04-27 added an alternative to heatmap to test, included create-pol_plane, set_pol_attitude, strongest_pol_attitude, (gks)
;
; 
;
;---------------------------------------------------



; Generate the attitude plane heatmap and set it in the beliefs hashmap.
to setup-heatmap
  let rows attitude_rows
  let cols attitude_cols
  
  let polLeft 12.6
  let polSoc 39.5
  let polMid 9.3
  let polCons 22.1
  let polRight 15.7
  
  let tier1 polLeft
  let tier2 polSoc + tier1
  let tier3 polMid + tier2
  let tier4 polCons + tier3
  let tier5 polRight + tier4
  
  
  ask voters [
    ;let rows attitude_rows
    ;let cols attitude_cols
    let max_heat 10

    let heatmap array:from-list n-values (cols * rows) [0]
;    array:set heatmap random int (rows * cols) random int max_heat
    
    let polVal  random(100)
    let polIndex 0
    
    if polVal < tier1                    [set polIndex 0]
    if tier1 < polVal and polVal < tier2 [set polIndex 1]
    if tier2 < polVal and polVal < tier3 [set polIndex 2]
    if tier3 < polVal and polVal < tier4 [set polIndex 3]
    if tier4 < polVal and polVal < tier5 [set polIndex 4]

    array:set heatmap (1 * cols + polIndex) 1
    add-belief create-belief "attitude-plane" heatmap
    let com center-of-mass heatmap
    set current_pol_attitude item 0 com 
  ]
  
   ; testing an alternative to heatmap
  ask voters [
    set current_pol_array array:from-list [-1 1 1 ]; initializing the array
    create-pol_plane]
  
 
  
  ask n-of (floor( num-agents * polLeft / 100.0)) voters with [array:item current_pol_array 0 = -1]
                                                [array:set current_pol_array 0 0
                                                 set_pol_attitude current_pol_array]
  ask n-of (floor( num-agents * polSoc / 100.0)) voters with [array:item current_pol_array 0 = -1]
                                                [array:set current_pol_array 0 1
                                                 set_pol_attitude current_pol_array]
  ask n-of (floor( num-agents * polMid / 100.0)) voters with [array:item current_pol_array 0 = -1]
                                                [array:set current_pol_array 0 2
                                                 set_pol_attitude current_pol_array]
  ask n-of (floor( num-agents * polCons / 100.0)) voters with [array:item current_pol_array 0 = -1]
                                                [array:set current_pol_array 0 3
                                                 set_pol_attitude current_pol_array]
  ask n-of (floor( num-agents * polRight / 100.0)) voters with [array:item current_pol_array 0 = -1]
                                                [array:set current_pol_array 0 4
                                                 set_pol_attitude current_pol_array]  
  
  ;rest if any
  ask voters with [array:item current_pol_array 0 = -1]
                                                [array:set current_pol_array 0 random 5
                                                 set_pol_attitude current_pol_array] 
   ; testing alternative to heatmap
   ask voters [
    let lpol strongest_pol_attitude
    print (word "voter:" who ": strongest pol_attitude: " lpol)
    print (word ": in parts-first item: " (item 0 lpol) " 2nd item:conv= " (item 1 lpol))
   ]  
  ; end testing alternative to heatmap
  
end


; Get the attitude plane current coordinate and the calculated
; conviction based on the attitude plane's heatmap.
;
; return [x y z] where (x, y) is the position and the z is the conviction value.
to-report center-of-mass [heatmap]
  let rows attitude_rows
  let cols attitude_cols

  ;let sum_mass 0
  let sum_mass 0.0
  ;let sum_particles list 0 0
  let sum_particles list 0.0 0.0
  foreach (n-values rows [i -> i]) [
    y -> foreach (n-values cols [j -> j]) [
      x ->
      ;let index y * rows + x
      let index y * cols + x
      let m array:item heatmap index

      let mx m * x
      let my m * y

      let sx item 0 sum_particles
      let sy item 1 sum_particles
      set sum_particles list (mx + sx) (my + sy)
      set sum_mass (sum_mass + m)
    ]
  ]
  if sum_mass = 0 [set sum_mass 1]
  ;let x round (item 0 sum_particles / sum_mass)
  ;let y round (item 1 sum_particles / sum_mass)
  ;let z array:item heatmap (y * rows + x)
  let x floor (item 0 sum_particles / sum_mass)
  let y floor (item 1 sum_particles / sum_mass)
  let z array:item heatmap (y * cols + x)
  report (list x y z)
end

; Sum the heat (x, y, z) conviction on our heatmap.
; This applies to the current agent.
to sum-heatmap [heat]
print "running heatmap"
print who
  let row attitude_rows
  let heatmap (item 1 (item 0 beliefs-of-type "attitude-plane"))
  let hx item 0 heat  ; x
  let hy item 1 heat  ; y
  let hz item 2 heat  ; z
  
  let index hy * row + hx
  let current_z array:item heatmap index
  array:set heatmap index (current_z + hz)
end

; Check if the incoming attitude message is within a range
; of our current position in the attitude plane
;
; true:  message is valid for attitude-plane summation
; false: message not satisfy the attitude-plane summation
to-report neighbour-check [message heatmap]
  let attitude_plane center-of-mass heatmap
  let apx item 0 attitude_plane
  let apy item 1 attitude_plane

  let mx item 0 message
  let my item 1 message

;  ; Euclidean distance
;  let dist_euclidean (apx - mx) * (apx - mx) + (apy - my) * (apy - my)
;  report dist_euclidean <= 1

  ; Manhattan distance
  let dist_x abs(apx - mx)
  let dist_y abs(apy - my)

  report dist_x <= 1 xor dist_y <= 1
end


; This controls our reactive layer.
to react-heatmap
  let conviction_queue beliefs-of-type "incoming-conviction"
end

to-report heatmap-eval
  let conviction_queue beliefs-of-type "incoming-conviction"
  report true
end




to create-pol_plane ;alternative to heatmap
  
  ; two look-up tables, one for the political plane with x-coordinates (pol spectrum 0-4), and y-coord (democracy spectrum 0-2),
  ; and one table conv_tbl for the political conviction. Both tables use the same keys.
  
  set pol_tbl table:make
  set conv_tbl table:make
  
  ;define the political table
  table:put pol_tbl "0 0" 0; key = polLeft/demAnti
  table:put pol_tbl "0 1" 0; key = polLeft/demNeutr
  table:put pol_tbl "0 2" 0; key = polLeft/demPos
  table:put pol_tbl "1 0" 0; key = polSoc/demAnti
  table:put pol_tbl "1 1" 0; key = polSoc/demNeutr
  table:put pol_tbl "1 2" 0; key = polSoc/demPos
  table:put pol_tbl "2 0" 0; key = polMid/demAnti
  table:put pol_tbl "2 1" 0; key = polMid/demNeutr
  table:put pol_tbl "2 2" 0; key = polMid/demPos
  table:put pol_tbl "3 0" 0; key = polCons/demAnti
  table:put pol_tbl "3 1" 0; key = polCons/demNeutr
  table:put pol_tbl "3 2" 0; key = polCons/demPos
  table:put pol_tbl "4 0" 0; key = polRight/demAnti
  table:put pol_tbl "4 1" 0; key = polRight/demNeutr
  table:put pol_tbl "4 2" 0; key = polRight/demPos

  ; devine the political convictions
  table:put conv_tbl "0 0" 0; key = conviction of polLeft/demAnti
  table:put conv_tbl "0 1" 0; key = conviction of polLeft/demNeutr
  table:put conv_tbl "0 2" 0; key = conviction of polLeft/demPos
  table:put conv_tbl "1 0" 0; key = conviction of polSoc/demAnti
  table:put conv_tbl "1 1" 0; key = conviction of polSoc/demNeutr
  table:put conv_tbl "1 2" 0; key = conviction of polSoc/demPos
  table:put conv_tbl "2 0" 0; key = conviction of polMid/demAnti
  table:put conv_tbl "2 1" 0; key = conviction of polMid/demNeutr
  table:put conv_tbl "2 2" 0; key = conviction of polMid/demPos
  table:put conv_tbl "3 0" 0; key = conviction of polCons/demAnti
  table:put conv_tbl "3 1" 0; key = conviction of polCons/demNeutr
  table:put conv_tbl "3 2" 0; key = conviction of polCons/demPos
  table:put conv_tbl "4 0" 0; key = conviction of polRight/demAnti
  table:put conv_tbl "4 1" 0; key = conviction of polRight/demNeutr
  table:put conv_tbl "4 2" 0; key = conviction of polRight/demPos
  
end

to set_pol_attitude [ pol_attitude] ; alternative to heatmap
  ;print word "in set_pol strXY= " strXY
  let strXY (word array:item pol_attitude 0 " " array:item pol_attitude 1)
  let conv array:item pol_attitude 2
  let counter table:get pol_tbl strXY
  set counter counter + 1
  table:put pol_tbl strXY counter
  table:put conv_tbl strXY conv
  ; debug only:
  print (word "set_pol_attitude: " strXY ", value= " table:get pol_tbl strXY ", conv=" (table:get conv_tbl strXY))
end



; alternative to finding the current_pol_attitude
; returns the X/Y coordinates of the pol_plane and the conviction value conv of the strongest attitude in a list
to-report strongest_pol_attitude
  ; finding the highest value
  let r (word -1 " " -1)
  let conv 0
  let m max table:values pol_tbl ;probably only takes the first that is the highest value
  ; find the keys to this value
  foreach ( table:keys pol_tbl ) [
    [key] -> let v table:get pol_tbl key 
    if v = m [set r  key
              set conv table:get conv_tbl key]
  ]
  report (list r conv)
end


